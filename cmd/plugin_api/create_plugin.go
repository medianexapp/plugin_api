package main

type FileTemplate struct {
	FileName string
	Content  string
}

const pluginImplTemplate = `package main

import (
	"log/slog"

	httpclient "github.com/medianexapp/plugin_api/httpclient"
	_ "github.com/medianexapp/plugin_api/httpclient"
	"github.com/medianexapp/plugin_api/plugin"

	_ "github.com/labulakalia/wazero_net/wasi/http" // if you need http import this
	_ "github.com/labulakalia/wazero_net/wasi/net" // if you need net.Conn import this
)

type PluginImpl struct {
}

func NewPluginImpl() *PluginImpl {
	slog.SetLogLoggerLevel(slog.LevelDebug)
	return &PluginImpl{
	}
}

// Id implements IPlugin.
func (p *PluginImpl) PluginId() (string, error) {
	return "{{.Id}}", nil
}

// GetAuth return how to auth
// 1.FormData input data
// 2.Callback use url callback auth,like oauth
// 3.Scanqrcode,return qrcode image to auth
func (p *PluginImpl) GetAuth() (*plugin.Auth, error) {
	slog.Info("GetAuth")
	auth := &plugin.Auth{
		AuthMethods: []*plugin.AuthMethod{},
	}
	return auth, nil
}

// CheckAuthMethod check auth is finished and return authDataBytes and authData's expired time
// if authmethod's type is *plugin.AuthMethod_Refresh,you need to refresh token
// assert authMethod.Method's type to check auth is finished,return auth data and expired time if authed
func (p *PluginImpl) CheckAuthMethod(authMethod *plugin.AuthMethod) (*plugin.AuthData, error) {
	slog.Debug("CheckAuthMethod", "authMethod", authMethod)
	panic("impl me")
}

// CheckAuthData use authDataBytes to uath
// you must store auth data to *PluginImpl
func (p *PluginImpl) CheckAuthData(authDataBytes []byte) error {
	slog.Debug("CheckAuthData", "authDataBytes", authDataBytes)
	panic("impl me")
}

// PluginAuthId implements IPlugin.
// plugin auth id,you can generate id by md5 or sha
func (p *PluginImpl) PluginAuthId() (string, error) {
	panic("impl me")
}

// GetDirEntry implements IPlugin.
// return dir file entry
// save your driver file raw data to FileEntry.RawData,you can get it after GetDirEntry and GetFileResource request
// default page_size if 100,if this not for you,change is on DirEntry.PageSize,will use new PageSize for next request
func (p *PluginImpl) GetDirEntry(req *plugin.GetDirEntryRequest) (*plugin.DirEntry, error) {
	slog.Debug("GetDirEntry", "req", req.FileEntry)
	panic("impl me")
}

// GetFileResource implements IPlugin.
func (p *PluginImpl) GetFileResource(req *plugin.GetFileResourceRequest) (*plugin.FileResource, error) {
	slog.Debug("GetFileResource", "req", req)
	panic("impl me")
}
`

var fileTemplates = []FileTemplate{
	{
		FileName: "{{ .Id }}.png",
		Content:  "empty image",
	},
	{
		FileName: ".gitignore",
		Content:  "dist",
	},
	{
		FileName: "Makefile",
		Content: `CHECK_PROGRAM := $(shell which plugin_api 2>/dev/null)
ifeq ($(CHECK_PROGRAM),)
   $(error "plugin_api not found,install cmd: go install github.com/medianexapp/plugin_api/cmd/plugin_api@latest")
endif
build:
	plugin_api build
`,
	},
	{
		FileName: "plugin.go",
		Content: `// Code generated by plugin_api. DO NOT EDIT.
//go:build wasip1

package main

import (
	"github.com/medianexapp/plugin_api"
)

func init() {
	plugin_api.RegistryPlugin(NewPluginImpl())
}

func main() {}
`,
	},

	{
		FileName: "plugin.toml",
		Content: `id = "{{.Id}}"
Name = "{{.Id}}"
desc = "{{.Id}} plugin desc"
icon = "{{.Id}}.png"
author = ["author@email.com"]
version = "v0.0.1"
changelog = ["{{.Id}} plugin init"]
`,
	},
	{
		FileName: "plugin_impl.go",
		Content:  pluginImplTemplate,
	},
	{
		FileName: "plugin_impl_test.go",
		Content: `package main

import (
	"strings"
	"testing"

	"github.com/medianexapp/plugin_api/plugin"
)

func TestPluginImpl(t *testing.T) {
	p := NewPluginImpl()
	auth, _ := p.GetAuth()
	method := auth.AuthMethods[0].Method
	method = method // <= save auth data
	 
	authData, err := p.CheckAuthMethod(&plugin.AuthMethod{
		Method: auth.AuthMethods[0].Method,
	})
	if err != nil {
		t.Fatal(err)
	}
	err = p.CheckAuthData(authData.AuthDataBytes)
	if err != nil {
		t.Fatal(err)
	}
	resp, err := p.GetDirEntry(&plugin.GetDirEntryRequest{
		Path:     "/",
		Page:     1,
		PageSize: 100,
	})
	if err != nil {
		t.Fatal(err)
	}
	for _, fileEntry := range resp.FileEntries {
		if fileEntry.FileType != plugin.FileEntry_FileTypeFile {
			continue
		}
		t.Log("file entry name", fileEntry.Name)
		// if is movie get file resource
		if strings.HasSuffix(fileEntry.Name, "mp4") || strings.HasSuffix(fileEntry.Name, "mkv") {
			fileResource, err := p.GetFileResource(&plugin.GetFileResourceRequest{
				FilePath:  "/" + fileEntry.Name,
				FileEntry: fileEntry,
			})
			if err != nil {
				t.Fatal(err)
			}
			t.Logf("get file %s fileResource %+v", fileEntry.Name, fileResource.FileResourceData)
		}
	}
	return
}
`,
	},
	{
		FileName: "go.mod",
		Content: `module testplugin

go 1.24.0

require (
	github.com/aperturerobotics/json-iterator-lite v1.0.0 // indirect
	github.com/aperturerobotics/protobuf-go-lite v0.9.1 // indirect
	github.com/labulakalia/wazero_net v0.0.9-0.20250427091815-5eb06e3a5aa6 // indirect
	github.com/medianexapp/plugin_api v0.0.25-0.20250427042910-f3bb62ff570f // indirect
	github.com/tetratelabs/wazero v1.9.0 // indirect
)
`,
	},
}
